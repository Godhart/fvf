# Объекты тестового окружения

## Введение

Как было сказано, объекты тестового окружения могут быть следующего типа:

* Объекты абстракции проверяемых сущностей а так же других сущностей, непосредственно участвующих в проверке, к которым 
можно обеспечить программный доступ прямым или косвенным образом

* Объекты из состава фреймворка для осуществления формиальной верификации
  
* Прочие объекты, описанные на языке Python, обеспечивающие дополнительные и связующие абстракции

Примеры проверяемых сущностей и других сущностей, учавствующих в проверке:
* Сетевой хост - узел в вычислительной сети (и для примера имеющий трансивер радиоканала определённого типа)
* Приложениие - экземпляр приложения запущенный на хосте, с которым возможно взаимодействие через TCP сокет
* Лампочка с управлением по радиоканалу
* Реле с управлением по радиоканалу
* Лампочка, подключенная к реле с управлением по радиокналу
* Датчик освещения, подключенный к контакту GPIO хоста
* Клапан, открытие и закрытие которого осуществляется механическим манипулятором, управялемым программно 
(к примеру - управяляемым программой, запущенной на хосте, с которой возможно взаимодействие посредством 
какого-либо интерфейса, к примеру TCP)
и т.п.

Примеры объектов, обеспечивающих дополнительные абстракции:
* Объект передачи данных через сокет TCP
* Объект выполнения запросов HTTP
* Объект выполнения запросов REST API

Объкеты формальной верификации:
* Rules - объект ввода формальной спецификации
* Scoreboard - объект контроля соответствия формальной спецификации
* Coverage - объект контроля полноты проверки в соответствии с формальной верификацией
* Sequencer - объект формирования воздействий

Эти объекты подробно рассмотрены в разделе [Объекты формальной верификации](d3_3_fv_objects.md)

## Основные принципы

В пакет `platforms` помещаются описания классов объектов тестового окружения.

Все описания должны быть классами Python и должны быть унаследованы от класса `PlatformBase` 
из модуля [platformix](../../src/core/platformix.py) пакета `core`, или от других классов, унаследованных от 
него.

Описание каждого класса должно содержаться в модуле `main` во вложенном пакете с именем, соответствующему типу объекта.
Класс опсания объекта тестового окружения дожен иметь имя `RootClass`. Ядро фреймворка производит иморт класса
объекта тестового окружения используя только эти имена.

Каждый объект абстракции сущности может быть связан только с одной сущностью.

Можно использовать следующие примеры описания классов объектов тестового окружения при чтении данного раздела:
* Класс объекта абстракции сетевого хоста: [Host](../../src/platforms/host/main.py)
* Класс объекта абстракции простого АЛУ: [Calc](../../src/platforms/calc/main.py)
* Класс объекта абстракции сервера запуска программ: [SoftwareRunner](../../src/platforms/software_runner/main.py)
* Класс вспомогательного объекта передачи байтовых потоков через сокет TCP: [TcpIO](../../src/platforms/tcpio/main.py)

## Исключения в именовании типов

В качестве названия типа объекта тестового окружения *запрещено* использовать следующие имена:
* `all`
* `any` 
* `coverage` *
* `include`
* `none`
* `others`
* `platforms`
* `platformix` **
* `probe` *
* `rules` *
* `scoreboard` *
* `sequencer` *
а так же имена, начинающиеся с `_` и заканчивающиеся на `_`.

\* - Объекты такого типа уже используются для формальной верификации \
\** - Базовый тип объектов тестового окружения

## Конструктор
При выполнении проверок объекты тестового окружения создаются на следующем шаге после загрузки описания тестового 
окружения. Необходимые значения параметров для конструктора задаются в описании тестового окружения.

_*! Внимание!* Следующие имена зарезервированы и *НЕ МОГУТ* быть использованы в аргументах конструктора:_
* `name`
* `description`
* `condition`
* `include`
* `platforms`
а так же имена, начинающиеся с `_` и заканчивающиеся на `_`.

В конструкторе должен находиться только код по иницализации переменных объекта, а так же подключение 
поддержки реализаций требуемых интерфейсов (протоколов).

Установка связи объекта с абстрагируемой сущностью, приведение её в определённое состояние перед проведением проверки и 
т.п. осуществляется на последующих этапах.

_*! Внимание!* Не забывайте про конструтор родительского класса! Он должен вызываться в первую очередь в констукторе 
объекта_

## Метод _start
Действия, необходимые для работы объекта тестового окружения при проведении проверки, такие как установка соединения, 
запуск внешнего приложения, копирование файлов, приведение абстрагируемой сущности в необходимое состояние и т.п. должно
осуществляться в методе `_start`.\
_*! Внимание!* В конце метода *\_start* должен вызываться метод `_start` наследуемого класса 
(т.е. `super(<class>, self)._start(...)`)_

## Метод _stop
Действия, необходимые после завершения проверки, такие как разрыв соединения, остановка внешнего 
приложения, удаление файлов при необходимости и т.п. должны осуществляться в методе `_stop`.\
_*! Внимание !* В конце метода *\_stop* должен вызываться метод `_stop` наследуемого класса 
(т.е. `super(<class>, self)._start(...)`)_

## Вызов методов _start и _stop
Метод `_start` вызывается системой выполнения тестов перед проведением проверки, метод `_stop` вызывается после 
проведения проверки.\
За время жизни объекта методы `_start` и `_stop` могут вызываться много раз - вплоть до вызова на каждую выполняемую 
проверку.

### Перечень обязательных методов и переменных

Помимо упомянутых методов `_start` и `_stop` каждый объект тестового окружения должен иметь перечисленные ниже методы и 
переменные. Все они входят в базовый класс `PlatformBase`.

### Поддержка протоколов

Перечисленные ниже методы и переменные должны присутствовать в объекте тестового окружения для обеспечения поддержки
любых протоколов.

В случае перекрытия приведённых здесь методов, их интерфейс (--сигнатура--) и суть выполняемых ими операций, должны 
сохраняться.

Назначение переменных меняться не должно.

*Методы:*
* `_reply`:     - отправка ответа
* `_reply_all`: - отправка ответа всем в списке
* `_register_reply_handler`:   - зарегистриовать call-back функцию реакции на ответ
* `_unregister_reply_handler`: - снять регистрацию call-back функции реакции на ответ

*Переменные:*
* `_running`:   - переменная типа *bool*. `True` обозначает, что объект запущен (успешно выполнил метод *\_start*)
и готов выполнять запросы. `False` обозначает, что объект ещё не запущен (не был запущен, ожидает завершения запуска, 
ожидает оставновки или остановлен) и соответственно не может выполнять запросы

### Интегарция с фреймворком

-- TODOC: описать --

-- TODOC: методы `send`, `request` и т.п. -- 

-- TODOC: переменные `_farm`, `_wait`, `_start_max_wait`, `_stop_max_wait` --

### Поддержка протокола 'platformix'

Протокол `platformix` обеспечивает корректное взаимодействие фреймворка с объектами тестового окружения (в частности 
запуск и их остановку), а так же базовые операции такие как прочитать/записать переменную или свойство (`@property`)
объекта, вызвать метод объекта, -- TODO: сделать слепок состояния--

Базовый клас `PlatformBase` изначально поддерживает этот протокол и производные от него классы не должны убирать эту 
поддержку.

Перечисленные разделом выше методы `_start` и `_stop` в т.ч. являются и реализацией методов базового протокола 
`platformix`.

Помимо данных методов в объекте должны иметься следующие переменные хранения контекста протокола `platformix`:
`_starting`, `_start_in_progress`, `_stopping`, `_stop_in_progress`.

Эти переменные так же уже есть в базовом классе `PlatformBase` и их использование не должно перекрываться производными
классами.

-- TODO: Метод '_snapshot' --

## Описание специфичного функционала

Функционал, специфичный для конкретного типа объекта тестового окружения и абсрагируемой им сущности, может быть описан
следующим образом:

### Свойства объекта

Описание специфичного функционала возможно за счёи добавления свойств объекта (`@property`), при обращении к которым 
будут выполняться неоходимые действия.

Значение свойства возвращается как результат. Такие обращения должны быть атомарными - не треобвать 
для корректной работы определённой последовательности обращений к другим свойствам объекта.

Для обращения к свойствам объекта используются методы `get` и `set` интерфейса `platformix`

Пример класса объекта тестового окружения, содержащего только свойства: [Host](../../src/platforms/host/main.py)

### Поддержка интерфейсов

Сложный функционал м.б. поддержан за счёт подключения поддержки определённых интерфейсов.

Поддержка какого любо интерфейса обеспечивается поддержкой одной из реализаций его протокола (далее просто протокола).
Для поддержки протокола, в объекте должны быть определены переменные и методы, указанные в специальных переменных класса
протокола.

Методы обеспечивают специфичную для этого объекта часть реализации протокола, а переменные обеспечивают хранение 
контекста протокола.

Поддержка протокола должна быть объявлена в конструкторе объекта тестового окружения, для подробностей см. раздел
[подключение поддержки интерфейса](d3_1_testenv_objects.md#Подключение-поддержки-интерфейса).

В случае отсутствия подходящего интерфейса или протокола он д.б. предварительно разработан и описан, для подробностей 
см. раздел [описание интерфейсов и протоколов](d3_2_interfaces_and_protocols.md).

Пример класса объекта тествого окружения, имеющего поддержку интерфейса: [Calc](../../src/platforms/calc/main.py)

## Подключение поддержки интерфейса

Для продолжения сперва следует ознакомиться с разделом [описание интерфейсов и протоколов](d3_2_interfaces_and_protocols.md)

### Общий принцип

Пакеты, вложенные в пакет `ip`, фактичеси представляют собой перечень возможных для поддержки интерфейсов - всё 
описание интерфейса с определённым именем, содержится внутри пакета с соответствующим именем.

Подключение поддержки интерфейса происходит неявно за счёт поддержки одной из реализаций его протокола.

Для поддержки требуемого протокола в первую очередь в модуле описания класса объекта тестового окружения необходимо 
импортировать класс описания требуемой реализации протокола, а так же класс создания объекта-обёртки для упрощения связи
этого протокола с объектом.

Для объявления поддержки необходимого протокола в конструкторе объекта тестового окружения вызывается метод 
`_support_protocol`, унаследованный от класса `PlatformBase`, в который передаётся свежесозданный экземпляр объекта 
реализации протокола требуемого интерфейса.

*Пример:*
* Подключение поддержки протокола 'arith' в конструкторе объекта класса `Calc` [src/platforms/calc/main.py](../../src/platforms/calc/main.py), 
* Описаниие самого интерфейса `arith`, протокола и класса создания объекта обёртки 
в модуле [definitions.py](../../src/ip/arith/definitions.py) пакета [ip/arith](../../src/ip/arith)

### Использование объекта-обёртки

Исходно при создании экземпляра объекта описания протокола в его конструктор требуется передать ссылку на объект, 
содержащий переменные хранения контекста и реализацию методов, с именами, указанными в переменных `_protocol_fields` и 
`_protocol_methods`  класса описания неоходимого протокола.

Для упомянутого в примере класса протокола `ArithProtocol` это:
* переменная `running`
* методы `sum`, `sub`, `mult`, `div`, `power`, `reply`, `reply_all`

Поскольку одной из целей создания данного фреймворка было в т.ч. упрощение описания, то для исключения создания сложной
иерархии классов изначально предусмотрено было использование самого объекта тестового окружения в качестве такого объекта.

Однако подход "в лоб" вызовет понятные неудобства из-за необходимости наличия требуемых имён переменных и методов
протокола в объекте тестового окружения, т.к. возможны пересечения имён а так же из-за наличия этих имеён в публичном доступе.
 
В связи с этим предлагается следующий механизм, который будет продемонстрирован подробно в следующем разделе:

1. Имена переменных и методов объекта, которые будут использованы протоколом, объявляются с использованием какого-либо 
префикса, общего для всех, относящемуся к одному протоколу. Подразумевается, что в простейшем случае в качестве префикса
будет символ подчёркивания `_`

2. После этого, в конструкторе объекта тестового окружения создаётся объект-обёртка с требуемыми для протокола именами методов и 
переменных. Этот объект создаётся автоматоматическим образом с помощью специального класса. В качестве параметров 
методу этого класса указывается сам объект тестового окружения и использованный общий префикс.

3. Этот объект-обёртка передаётся в качестве параметра в конструктор протокола.

4. Обращения из протокола к методам и свойствам этого объекта-обёртки будут переадресовываться к методам и переменным 
объекта тестового окружения.

### Возможные варианты

Как указано выше для поддержки одной из реализаций протокола интерфейса необходимо в описании класса объектта тестового
окружения объявить требуемые для данной реализации протокола переменные а так же реализовать требуемые методы.

Ниже приведены примеры вариантов реализации этого требования.

К примеру для поддержки упоминавшегося раннее протокола `arith` в объекте тестового окружения необходимо иметь 
переменную `running` и методы `sum`, `sub`, `mult`, `div`, `power`, `reply`, `reply_all`, 
причём `running`, `reply`, `reply_all` являются общими для всех протоколов, как было указано в разделе 
[Поддержка протоколов](d3_1_testenv_objects.md#Поддержка-протоколов)

#### Вариант I (по умполчанию)
Поскольку `running`, `reply_all` и `reply` есть в каждом объекте тестового окружения и имеют префикс `_`, то для простоты 
можно использовать этот же префикс для имён переменных и методов протокола 

1. В класс добавляются недостающие методы `_sum`, `_sub`, `_mult`, `_div`, `_power`

2. В конструкторе объекта добавляется следующий код:

```python
# Создание объекта-обёртки. ArithWrapper - класс из модуля определения интерфейса 'arith' (src/ip/arith/definitions.py)
arith = ArithWrapper.get_wrapper(host=self, prefix="_", mmap=None, fmap=None)
# Добавление протокола в перечень поддерживаемых объектом
self._support_protocol(ArithProtocol(host=self, worker=arith))
```

для кратакости можно так:

```python
self._support_protocol(ArithProtocol(self, ArithWrapper.get_wrapper(self, "_")))
```

[Код класса создания объекта-обёртки](../../src/ip/arith/definitions.py)

#### Вариант II (создание свойств-алиасов и методов-алиасов)
В более сложном случае, если бы один из методов `_sum`, `_sub`, `_mult`, `_div`, `_power` пересекался с другими методами
класса объекта тестового окружения, в т.ч. для поддержки какого-то другого протокола возможно было бы решить задачу 
следующими способом:

1. Использовать другой префикс для методов `sum`, `sub` и т.д. (в данном примере используется префикс `_arith_`)
Т.е. в класс будут добавлены методы `_arith_sum`, `_arith_sub`, `_arith_mult`, `_arith_div`, `_arith_power`

2. Созздать алиасы для переменной `_running`, и методов `_reply` и `_reply_all` с нужным префиксом следующим образом:
```python
self._make_proto_aliases('_arith_') # -- TODO: поддержать --
# Этот метод добавит в объект следующие методы и переменные:
#   self._arith_running = alias_property(self._running)
#   self._arith_reply = alias_method(self._reply)
#   self._arith_running = alias_method(self._reply_all)
```

3. Добавить код в конструктор с указанием использованного префикса (отличается от варианта 1 только префиксом):

```python
self._support_protocol(ArithProtocol(self, ArithWrapper.get_wrapper(self, "_arith_")))
```

Данный вариант хорош тем, что префиксом явно выделяются переменные и методы, относящиеся к поддержке определённого
протокола, однако требуется немного больше кода

#### Вариант III (явное указание соответствия имён)
Адьтернативное решение проблемы, описанной в варианте II - т.е. случая, если бы одно из имён методов `_sum`, `_sub`, 
`_mult`, `_div`, `_power` пересекалось с другими методами объекта тестового окружения:

1. Для того метода, имя которого пересекается с сущесвующим использовать другой префикс. 
Для примера пусть это будет метод `sum` и пусть он будет реализован методом `_arith_sum`, 
остальные - реализуются методами с префиксом по умолчанию, т.е. в объекте ещё 
будут методы `_sub`, `_mult`, `_div`, `_power`

2. При создании объекта обёртки указывать соответствие имени метода, префикс которого отличается от общего с помощью 
аргумента `fmap`:

```python
arith = ArithWrapper.get_wrapper(host=self, prefix="_", fmap={'sum':'_arith_sum'})
self._support_protocol(ArithProtocol(self, arith))
```

Аналогичным способом возможно задавть соотетствие имён переменных через аргуента `mmap`, т.е. в варианте II можно было 
бы обойтись без дополнительных алиасов следующим образом:

```python
arith = ArithWrapper.get_wrapper(
    host=self,
    prefix="_arith_",                                         # Префикс по умолчанию (для варинта II)
    mmap={'running':'_running'},                              # Соответствие имён переменных
    fmap={'reply':self._reply, 'reply_all':self._reply_all}   # Соответствие имён методов
)                       

self._support_protocol(ArithProtocol(self, arith))
```
