# Описание интерфейсов и протоколов

## Общие принципы

Интерфейсы позволяют обеспечить взамодействие с объектами тестового окружения на уровне вызова и выполнения методов.
Каждый интерфейс имеет описание входящих в него методов, позволяющее контролировать корректность вызовов и возвращаемых
значений. Реализация методов интерфейса обеспечивается протоколом. Может быть несколько реализаций одного интерфейса.

Описание интерфейсов и протоколов содержится в каталоге `ip`, которрый является пакетом Python.

Описание каждого интерфейса и соответствующих ему реализаций протокола должны содержаться во вложенном пакете с именем, 
соответствующим имени интерфейса. В данном пакете должен содержаться модуль Python с именем `definitions`, содержащий:
* класс описания интерфейса на основе класса [PlatformInterfaceCore](../../src/core/platformix_core.py)
* один или несколько классов описания протокола на основе класса [PlatformProtocolCore](../../src/core/platformix_core.py)
* классы создения объекта-обёртки по одному на каждый класс описания протокола на основе класса [Wrapper](../../src/core/helpers.py)

Интерфейс описывает набор методов, их аргументов и тип возвращаемого результата. Протоколы описывают логику выполнения
метода интерфейса с учётом той или иной специфики и хотя одному интерфейсу могут соответствовать неколько реализаций 
протоколов, при этом все они фактически должны обеспечивать один функционал, определяемый самим интерфейсом.

В частности разные реализации протокола могут требовать от объекта тестового окружения разные методы и переменные хранения
контекста протокола для реализации тех или иных вещей, но логика метода, которую они реализуют должна быть одинакова.

С определённой точки зрения каждый метода интерфейса является "точкой входа" для выполнения того или иного правила, 
описанного протоколом.

Для поддержки того или иного интерфейса объект тестового окружения должен обеспечить его поддержку, которая заключается
в создании им объекта протокола (одного из возможных для требуемого интерфейса), включения этого объекта в список 
поддерживаемых им протоколов, объявления необходмых для протокола переменных и реализации необходимых для протокола 
методов. Подробнее поддержка 

-- TODO: Вопрос поддержки многошаговых протоколов, в которых инициатор должен отвечать в ходе выполнения -- 
-- Вероятно так: --
2 набора классов интерфейсов/протоколов - один для отвечающего (по умолчанию именно он и описывается), другой - 
для вызывающего.
Возможно в этом случае необходимо вызывать в первую очередь метод вызывающего протокола (т.е. фактически делать запрос 
самому себе), но есть нюанс в текущей системе передачи сообщений - она не отправит вызов самому себе.
Кроме этого нужно расширить типы сообщений, для отличия промежуточных результатов при взаимодйствии от окончательных.

## Описание интерфейса

Описание самого интерфейса лаклнично и содержит лишь перечень имён методов, а так же имя самого интерфейса

-- TODO: возможно есть смысл воспольщзоваться механизмом виртуальных методов Python (ABC)? 
Но в нём сигнатура не предусматривает указание ?типов аргументов? и возвращаемого типа? --

Пример описания интерфейса [stream_io](../../src/ip/stream_io/definitions.py):
```python
class StreamIOInterface(PlatformInterfaceCore):
    """
    Interface for bytestreams input and output
    """
    _base_id = "stream_io"           # Имя интерфейса
    _methods = ("send", "receive")   # Перечень методов
    # На данном этапе реализации требуемая сигнатура методов не указывается, будет добавлено в последствии
    # Methods:  На данный момент даётся лишь методов интерфейса в коментариях
    # * send - send data
    #   * args: data - string/bytearray or list of strings/bytearrays
    # * receive - receives data
    #   * args: count - amount of lines to receive
```

## Описание реализации протокола

Описание реализаци протокола содержит реализацию всех методов интерфейса а так же перечень переменных и методов, 
наличие которых требуется в объекте тестового окружения, который будет поддерживать этот протокол

Пример описания реализации протокола для интерфейса [stream_io](../../src/ip/stream_io/definitions.py):
```python
class StreamIOProtocol(PlatformProtocolCore):
    """
    Implements StreamIO interface
    """
    _default_interface = StreamIOInterface      # Интерфейс, которому соответствует реализация протокола
    _protocol_fields = ("running", )            # Необходимые переменные объекта тестового окружения
    _protocol_methods = ("send", "receive", "reply", "reply_all")  # Необходимые методы объекта тестового окружения
    
    

    # Реализация метода send. Имя метода составляется по правилу: '_' + <имя_интерфейса> + '_' + <имя_метода>
    def _stream_io_send(self, context, fake_reply, data):
        # В каждом методе реализации интерфейса есть два обязательных аргумента
        # context - определяет контекст выполнения метода. 
        #   Он содержит:
        #   * имя интерфейса, использованного для приёма сообщения
        #   * имя канала, из которого пришло сообщение и в который нужно отправить ответ
        #   * номер потока (thread) сообщений, из которого пришло сообщение и в который нужно отправить ответ
        #   Подробности про имя канала, потока и принципе вызова метода см. в разделе --...--
        # fake_reply - параметр подстановки "ложного" ответа вместо действительного
        # Прочие аргументы относятся к самому вызываемому методу
        if not self._ensure_running(context, fake_reply):   # В начале всегда следует убедиться, что объект тестового окружения запущен
            return
        self._notify(context, "Calling send...")    # Послать уведомление в первую очередь о приёме вызова, 
        # чтобы система передачи сообщений отметила этое объект как активного исполнителя запроса 
        # и ждала завершающего ответа (примечание - активных исполнителей м.б. одновременно несколько)
        self._reply(context,                        # Послать завершающий ответ
                    self._worker.send(context, data),   # В котором результат выполнения метода объектом
                    fake_reply)                         # или "ложный" ответ если такой был указан в вызове

    # Реализация метода receive. Имя метода составляется по правилу: '_' + <имя_интерфейса> + '_' + <имя_метода>
    def _stream_io_receive(self, context, fake_reply, count=0, timeout=None, decode='UTF-8'):
        if not self._ensure_running(context, fake_reply):
            return
        self._notify(context, "Calling receive...")
        self._reply(context, self._worker.receive(context, count, timeout, decode), fake_reply)
```

## Класс обёртки

Так же в модуле с описанием реализации протокола содержится описание класса-обёртки для этой реализации, 
которое всегда создаётся по одному шаблону.

Пример описания обёртки реализации протокола интерфейса [stream_io](../../src/ip/stream_io/definitions.py):

```python
class StreamIOWrapper(Wrapper):
    """
    Use to map platform's methods and fields into worker, required by SoftwareRunnerProtocol
    """
    _methods = StreamIOProtocol._protocol_methods  # Перечень методов протокола
    _fields = StreamIOProtocol._protocol_fields    # Перечень переменных хранения контекста протокола
```
